// generated by cdk8s
import { ApiObject } from 'cdk8s';
import { Construct } from 'constructs';

/**
 * HTTPRoute is the Schema for the HTTPRoute resource.
 *
 * @schema HTTPRoute
 */
export class HttpRoute extends ApiObject {
  /**
   * Defines a "HTTPRoute" API object
   * @param scope the scope in which to define this object
   * @param name a scope-local name for the object
   * @param options configuration options
   */
  public constructor(scope: Construct, name: string, options: HttpRouteOptions = {}) {
    super(scope, name, {
      ...options,
      kind: 'HTTPRoute',
      apiVersion: 'networking.x-k8s.io/v1alpha1',
    });
  }
}

/**
 * HTTPRoute is the Schema for the HTTPRoute resource.
 *
 * @schema HTTPRoute
 */
export interface HttpRouteOptions {
  /**
   * @schema HTTPRoute#metadata
   */
  readonly metadata?: any;

  /**
   * HTTPRouteSpec defines the desired state of HTTPRoute
   *
   * @schema HTTPRoute#spec
   */
  readonly spec?: HttpRouteSpec;

}

/**
 * HTTPRouteSpec defines the desired state of HTTPRoute
 *
 * @schema HttpRouteSpec
 */
export interface HttpRouteSpec {
  /**
   * Hosts is a list of Host definitions.
   *
   * @schema HttpRouteSpec#hosts
   */
  readonly hosts?: HttpRouteSpecHosts[];

}

/**
 * HTTPRouteHost is the configuration for a given set of hosts.
 *
 * @schema HttpRouteSpecHosts
 */
export interface HttpRouteSpecHosts {
  /**
   * ExtensionRef is an optional, implementation-specific extension to the "host" block. The resource may be "configmaps"  or an implementation-defined resource (for example, resource "myroutehosts" in group "networking.acme.io"). 
 If the referent cannot be found, the GatewayClass's "InvalidParameters" status condition will be true. 
 Support: custom
   *
   * @schema HttpRouteSpecHosts#extensionRef
   */
  readonly extensionRef?: HttpRouteSpecHostsExtensionRef;

  /**
   * Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request. Hostname is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the "host" part of the URI as defined in the RFC: 
 1. IPs are not allowed. 2. The `:` delimiter is not respected because ports are not allowed. 
 Incoming requests are matched against the hostnames before the HTTPRoute rules. If no hostname is specified, traffic is routed based on the HTTPRouteRules. 
 Hostname can be "precise" which is a domain name without the terminating dot of a network host (e.g. "foo.example.com") or "wildcard", which is a domain name prefixed with a single wildcard label (e.g. "*.example.com"). The wildcard character '*' must appear by itself as the first DNS label and matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*"). Requests will be matched against the Host field in the following order: 1. If Host is precise, the request matches this rule if    the http host header is equal to Host. 2. If Host is a wildcard, then the request matches this rule if    the http host header is to equal to the suffix    (removing the first label) of the wildcard rule. 
 Support: Core
   *
   * @schema HttpRouteSpecHosts#hostnames
   */
  readonly hostnames?: string[];

  /**
   * Rules are a list of HTTP matchers, filters and actions.
   *
   * @schema HttpRouteSpecHosts#rules
   */
  readonly rules: HttpRouteSpecHostsRules[];

}

/**
 * ExtensionRef is an optional, implementation-specific extension to the "host" block. The resource may be "configmaps"  or an implementation-defined resource (for example, resource "myroutehosts" in group "networking.acme.io"). 
 If the referent cannot be found, the GatewayClass's "InvalidParameters" status condition will be true. 
 Support: custom
 *
 * @schema HttpRouteSpecHostsExtensionRef
 */
export interface HttpRouteSpecHostsExtensionRef {
  /**
   * Group is the API group name of the referent.
   *
   * @schema HttpRouteSpecHostsExtensionRef#group
   */
  readonly group: string;

  /**
   * Name is the name of the referent.
   *
   * @schema HttpRouteSpecHostsExtensionRef#name
   */
  readonly name: string;

  /**
   * Resource is the API resource name of the referent.
   *
   * @schema HttpRouteSpecHostsExtensionRef#resource
   */
  readonly resource: string;

}

/**
 * HTTPRouteRule defines semantics for matching an incoming HTTP request against a set of matching rules and executing an action (and optionally filters) on the request.
 *
 * @schema HttpRouteSpecHostsRules
 */
export interface HttpRouteSpecHostsRules {
  /**
   * Filters define the filters that are applied to requests that match this rule. 
 The effects of ordering of multiple behaviors are currently undefined. This can change in the future based on feedback during the alpha stage. 
 Conformance-levels at this level are defined based on the type of filter: - ALL core filters MUST be supported by all implementations. - Implementers are encouraged to support extended filters. - Implementation-specific custom filters have no API guarantees across implementations. Specifying a core filter multiple times has undefined or custom conformance. 
 Support: core
   *
   * @schema HttpRouteSpecHostsRules#filters
   */
  readonly filters?: HttpRouteSpecHostsRulesFilters[];

  /**
   * Forward defines the upstream target(s) where the request should be sent.
   *
   * @schema HttpRouteSpecHostsRules#forward
   */
  readonly forward?: HttpRouteSpecHostsRulesForward;

  /**
   * Matches define conditions used for matching the rule against incoming HTTP requests. Each match is independent, i.e. this rule will be matched if **any** one of the matches is satisfied. 
 For example, take the following matches configuration: 
 ``` matches: - path:     value: "/foo"   headers:     values:       version: "2" - path:     value: "/v2/foo" ``` 
 For a request to match against this rule, a request should satisfy EITHER of the two conditions: 
 - path prefixed with `/foo` AND contains the header `version: "2"` - path prefix of `/v2/foo` 
 See the documentation for HTTPRouteMatch on how to specify multiple match conditions that should be ANDed together. 
 If no matches are specified, the default is a prefix path match on "/", which has the effect of matching every HTTP request.
   *
   * @schema HttpRouteSpecHostsRules#matches
   */
  readonly matches?: HttpRouteSpecHostsRulesMatches[];

}

/**
 * HTTPRouteFilter defines additional processing steps that must be completed during the request or response lifecycle. HTTPRouteFilters are meant as an extension point to express additional processing that may be done in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. API guarantee/conformance is defined based on the type of the filter. TODO(hbagdi): re-render CRDs once controller-tools supports union tags: - https://github.com/kubernetes-sigs/controller-tools/pull/298 - https://github.com/kubernetes-sigs/controller-tools/issues/461
 *
 * @schema HttpRouteSpecHostsRulesFilters
 */
export interface HttpRouteSpecHostsRulesFilters {
  /**
   * ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  The resource may be "configmap" (use the empty string for the group) or an implementation-defined resource (for example, resource "myroutefilters" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "configmaps". ExtensionRef MUST NOT be used for core and extended filters.
   *
   * @schema HttpRouteSpecHostsRulesFilters#extensionRef
   */
  readonly extensionRef?: HttpRouteSpecHostsRulesFiltersExtensionRef;

  /**
   * HTTPRequestHeaderFilter defines configuration for the RequestHeader filter.
   *
   * @schema HttpRouteSpecHostsRulesFilters#requestHeader
   */
  readonly requestHeader: HttpRouteSpecHostsRulesFiltersRequestHeader;

  /**
   * HTTPRequestMirrorFilter defines configuration for the RequestMirror filter.
   *
   * @schema HttpRouteSpecHostsRulesFilters#requestMirror
   */
  readonly requestMirror: HttpRouteSpecHostsRulesFiltersRequestMirror;

  /**
   * Type identifies the filter to execute. Types are classified into three conformance-levels (similar to other locations in this API): - Core and extended: These filter types and their corresponding configuration   is defined in this package. All implementations must implement   the core filters. Implementers are encouraged to support extended filters.   Definitions for filter-specific configuration for these   filters is defined in this package. - Custom: These filters are defined and supported by specific vendors.   In the future, filters showing convergence in behavior across multiple   implementations will be considered for inclusion in extended or core   conformance rings. Filter-specific configuration for such filters   is specified using the ExtensionRef field. `Type` should be set to   "ImplementationSpecific" for custom filters. 
 Implementers are encouraged to define custom implementation types to extend the core API with implementation-specific behavior.
   *
   * @schema HttpRouteSpecHostsRulesFilters#type
   */
  readonly type: string;

}

/**
 * Forward defines the upstream target(s) where the request should be sent.
 *
 * @schema HttpRouteSpecHostsRulesForward
 */
export interface HttpRouteSpecHostsRulesForward {
  /**
   * ExtensionRef is an optional, implementation-specific extension to the "action" behavior.  The resource may be "configmaps" (use the empty string for the group) or an implementation-defined resource (for example, resource "myrouteactions" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "configmaps".  If the referent cannot be found, the "InvalidRoutes" status condition on any Gateway that includes the HTTPRoute will be true. 
 Support: custom
   *
   * @schema HttpRouteSpecHostsRulesForward#extensionRef
   */
  readonly extensionRef?: HttpRouteSpecHostsRulesForwardExtensionRef;

  /**
   * To references referenced object(s) where the request should be sent. The resource may be "services" (omit or use the empty string for the group), or an implementation may support other resources (for example, resource "myroutetargets" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "services".  If the referent cannot be found, the "InvalidRoutes" status condition on any Gateway that includes the HTTPRoute will be true. 
 Support: core
   *
   * @schema HttpRouteSpecHostsRulesForward#to
   */
  readonly to: HttpRouteSpecHostsRulesForwardTo[];

}

/**
 * HTTPRouteMatch defines the predicate used to match requests to a given action. Multiple match types are ANDed together, i.e. the match will evaluate to true only if all conditions are satisfied. 
 For example, the match below will match a HTTP request only if its path starts with `/foo` AND it contains the `version: "1"` header: 
 ``` match:   path:     value: "/foo"   headers:     values:       version: "1" ```
 *
 * @schema HttpRouteSpecHostsRulesMatches
 */
export interface HttpRouteSpecHostsRulesMatches {
  /**
   * ExtensionRef is an optional, implementation-specific extension to the "match" behavior.  The resource may be "configmap" (use the empty string for the group) or an implementation-defined resource (for example, resource "myroutematchers" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "configmaps".  If the referent cannot be found, the "InvalidRoutes" status condition on any Gateway that includes the HTTPRoute will be true. 
 Support: custom
   *
   * @schema HttpRouteSpecHostsRulesMatches#extensionRef
   */
  readonly extensionRef?: HttpRouteSpecHostsRulesMatchesExtensionRef;

  /**
   * Headers specifies a HTTP request header matcher.
   *
   * @schema HttpRouteSpecHostsRulesMatches#headers
   */
  readonly headers?: HttpRouteSpecHostsRulesMatchesHeaders;

  /**
   * Path specifies a HTTP request path matcher. If this field is not specified, a default prefix match on the "/" path is provided.
   *
   * @schema HttpRouteSpecHostsRulesMatches#path
   */
  readonly path?: HttpRouteSpecHostsRulesMatchesPath;

}

/**
 * ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  The resource may be "configmap" (use the empty string for the group) or an implementation-defined resource (for example, resource "myroutefilters" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "configmaps". ExtensionRef MUST NOT be used for core and extended filters.
 *
 * @schema HttpRouteSpecHostsRulesFiltersExtensionRef
 */
export interface HttpRouteSpecHostsRulesFiltersExtensionRef {
  /**
   * Group is the API group name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesFiltersExtensionRef#group
   */
  readonly group: string;

  /**
   * Name is the name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesFiltersExtensionRef#name
   */
  readonly name: string;

  /**
   * Resource is the API resource name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesFiltersExtensionRef#resource
   */
  readonly resource: string;

}

/**
 * HTTPRequestHeaderFilter defines configuration for the RequestHeader filter.
 *
 * @schema HttpRouteSpecHostsRulesFiltersRequestHeader
 */
export interface HttpRouteSpecHostsRulesFiltersRequestHeader {
  /**
   * Add adds the given header (name, value) to the request before the action. 
 Input:   GET /foo HTTP/1.1 
 Config:   add: {"my-header": "foo"} 
 Output:   GET /foo HTTP/1.1   my-header: foo 
 Support: extended?
   *
   * @schema HttpRouteSpecHostsRulesFiltersRequestHeader#add
   */
  readonly add: { [key: string]: string };

  /**
   * Remove the given header(s) from the HTTP request before the action. The value of RemoveHeader is a list of HTTP header names. Note that the header names are case-insensitive [RFC-2616 4.2]. 
 Input:   GET /foo HTTP/1.1   My-Header1: ABC   My-Header2: DEF   My-Header2: GHI 
 Config:   remove: ["my-header1", "my-header3"] 
 Output:   GET /foo HTTP/1.1   My-Header2: DEF 
 Support: extended?
   *
   * @schema HttpRouteSpecHostsRulesFiltersRequestHeader#remove
   */
  readonly remove: string[];

}

/**
 * HTTPRequestMirrorFilter defines configuration for the RequestMirror filter.
 *
 * @schema HttpRouteSpecHostsRulesFiltersRequestMirror
 */
export interface HttpRouteSpecHostsRulesFiltersRequestMirror {
  /**
   * TargetPort specifies the destination port number to use for the TargetRef. If unspecified and TargetRef is a Service object consisting of a single port definition, that port will be used. If unspecified and TargetRef is a Service object consisting of multiple port definitions, an error is surfaced in status. 
 Support: Core
   *
   * @schema HttpRouteSpecHostsRulesFiltersRequestMirror#targetPort
   */
  readonly targetPort?: number;

  /**
   * TargetRef is an object reference to forward matched requests to. The resource may be "services" (omit or use the empty string for the group), or an implementation may support other resources (for example, resource "myroutetargets" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "services".  If the referent cannot be found, the "InvalidRoutes" status condition on any Gateway that includes the HTTPRoute will be true. 
 Support: Core (Kubernetes Services) Support: Implementation-specific (Other resource types)
   *
   * @schema HttpRouteSpecHostsRulesFiltersRequestMirror#targetRef
   */
  readonly targetRef: HttpRouteSpecHostsRulesFiltersRequestMirrorTargetRef;

}

/**
 * ExtensionRef is an optional, implementation-specific extension to the "action" behavior.  The resource may be "configmaps" (use the empty string for the group) or an implementation-defined resource (for example, resource "myrouteactions" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "configmaps".  If the referent cannot be found, the "InvalidRoutes" status condition on any Gateway that includes the HTTPRoute will be true. 
 Support: custom
 *
 * @schema HttpRouteSpecHostsRulesForwardExtensionRef
 */
export interface HttpRouteSpecHostsRulesForwardExtensionRef {
  /**
   * Group is the API group name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesForwardExtensionRef#group
   */
  readonly group: string;

  /**
   * Name is the name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesForwardExtensionRef#name
   */
  readonly name: string;

  /**
   * Resource is the API resource name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesForwardExtensionRef#resource
   */
  readonly resource: string;

}

/**
 * HTTPForwardToTarget identifies a target object within a known namespace.
 *
 * @schema HttpRouteSpecHostsRulesForwardTo
 */
export interface HttpRouteSpecHostsRulesForwardTo {
  /**
   * Filters defined at this-level should be executed if and only if the request is being forwarded to the target defined here. 
 Conformance: For any implementation, filtering support, including core filters, is NOT guaranteed at this-level. Use Filters in HTTPRouteRule for portable filters across implementations. 
 Support: custom
   *
   * @schema HttpRouteSpecHostsRulesForwardTo#filters
   */
  readonly filters?: HttpRouteSpecHostsRulesForwardToFilters[];

  /**
   * TargetPort specifies the destination port number to use for the TargetRef. If unspecified and TargetRef is a Service object consisting of a single port definition, that port will be used. If unspecified and TargetRef is a Service object consisting of multiple port definitions, an error is surfaced in status. 
 Support: Core
   *
   * @schema HttpRouteSpecHostsRulesForwardTo#targetPort
   */
  readonly targetPort?: number;

  /**
   * TargetRef is an object reference to forward matched requests to. The resource may be "services" (omit or use the empty string for the group), or an implementation may support other resources (for example, resource "myroutetargets" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "services".  If the referent cannot be found, the "InvalidRoutes" status condition on any Gateway that includes the HTTPRoute will be true. 
 Support: Core (Kubernetes Services) Support: Implementation-specific (Other resource types)
   *
   * @schema HttpRouteSpecHostsRulesForwardTo#targetRef
   */
  readonly targetRef: HttpRouteSpecHostsRulesForwardToTargetRef;

  /**
   * Weight specifies the proportion of traffic forwarded to a targetRef, computed as weight/(sum of all weights in targetRefs). Weight is not a percentage and the sum of weights does not need to equal 100. The following example (in yaml) sends 70% of traffic to service "my-trafficsplit-sv1" and 30% of the traffic to service "my-trafficsplit-sv2": 
   forwardTo:     - targetRef:         name: my-trafficsplit-sv1         weight: 70     - targetRef:         name: my-trafficsplit-sv2         weight: 30 
 If only one targetRef is specified, 100% of the traffic is forwarded to the targetRef. If unspecified, weight defaults to 1. 
 Support: Core (HTTPRoute) Support: Extended (TCPRoute)
   *
   * @schema HttpRouteSpecHostsRulesForwardTo#weight
   */
  readonly weight?: number;

}

/**
 * ExtensionRef is an optional, implementation-specific extension to the "match" behavior.  The resource may be "configmap" (use the empty string for the group) or an implementation-defined resource (for example, resource "myroutematchers" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "configmaps".  If the referent cannot be found, the "InvalidRoutes" status condition on any Gateway that includes the HTTPRoute will be true. 
 Support: custom
 *
 * @schema HttpRouteSpecHostsRulesMatchesExtensionRef
 */
export interface HttpRouteSpecHostsRulesMatchesExtensionRef {
  /**
   * Group is the API group name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesMatchesExtensionRef#group
   */
  readonly group: string;

  /**
   * Name is the name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesMatchesExtensionRef#name
   */
  readonly name: string;

  /**
   * Resource is the API resource name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesMatchesExtensionRef#resource
   */
  readonly resource: string;

}

/**
 * Headers specifies a HTTP request header matcher.
 *
 * @schema HttpRouteSpecHostsRulesMatchesHeaders
 */
export interface HttpRouteSpecHostsRulesMatchesHeaders {
  /**
   * HeaderMatchType specifies how to match a HTTP request header against the Values map. 
 Support: core (Exact) Support: custom (ImplementationSpecific) 
 Default: "Exact"
   *
   * @schema HttpRouteSpecHostsRulesMatchesHeaders#type
   */
  readonly type?: HttpRouteSpecHostsRulesMatchesHeadersType;

  /**
   * Values is a map of HTTP Headers to be matched. It MUST contain at least one entry. 
 The HTTP header field name to match is the map key, and the value of the HTTP header is the map value. HTTP header field names MUST be matched case-insensitively. 
 Multiple match values are ANDed together, meaning, a request must match all the specified headers to select the route.
   *
   * @schema HttpRouteSpecHostsRulesMatchesHeaders#values
   */
  readonly values: { [key: string]: string };

}

/**
 * Path specifies a HTTP request path matcher. If this field is not specified, a default prefix match on the "/" path is provided.
 *
 * @schema HttpRouteSpecHostsRulesMatchesPath
 */
export interface HttpRouteSpecHostsRulesMatchesPath {
  /**
   * Type specifies how to match against the path Value. 
 Support: core (Exact, Prefix) Support: custom (RegularExpression, ImplementationSpecific) 
 Since RegularExpression PathType has custom conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect. 
 Default: "Prefix"
   *
   * @schema HttpRouteSpecHostsRulesMatchesPath#type
   */
  readonly type?: HttpRouteSpecHostsRulesMatchesPathType;

  /**
   * Value of the HTTP path to match against.
   *
   * @schema HttpRouteSpecHostsRulesMatchesPath#value
   */
  readonly value: string;

}

/**
 * TargetRef is an object reference to forward matched requests to. The resource may be "services" (omit or use the empty string for the group), or an implementation may support other resources (for example, resource "myroutetargets" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "services".  If the referent cannot be found, the "InvalidRoutes" status condition on any Gateway that includes the HTTPRoute will be true. 
 Support: Core (Kubernetes Services) Support: Implementation-specific (Other resource types)
 *
 * @schema HttpRouteSpecHostsRulesFiltersRequestMirrorTargetRef
 */
export interface HttpRouteSpecHostsRulesFiltersRequestMirrorTargetRef {
  /**
   * Group is the group of the referent.  Omitting the value or specifying the empty string indicates the core API group.  For example, use the following to specify a service: 
 fooRef:   resource: services   name: myservice 
 Otherwise, if the core API group is not desired, specify the desired group: 
 fooRef:   group: acme.io   resource: foos   name: myfoo
   *
   * @schema HttpRouteSpecHostsRulesFiltersRequestMirrorTargetRef#group
   */
  readonly group?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesFiltersRequestMirrorTargetRef#name
   */
  readonly name: string;

  /**
   * Resource is the API resource name of the referent. Omitting the value or specifying the empty string indicates the services resource. For example, use the following to specify a services resource: 
 fooRef:   name: myservice 
 Otherwise, if the services resource is not desired, specify the desired group: 
 fooRef:   group: acme.io   resource: foos   name: myfoo
   *
   * @schema HttpRouteSpecHostsRulesFiltersRequestMirrorTargetRef#resource
   */
  readonly resource?: string;

}

/**
 * HTTPRouteFilter defines additional processing steps that must be completed during the request or response lifecycle. HTTPRouteFilters are meant as an extension point to express additional processing that may be done in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. API guarantee/conformance is defined based on the type of the filter. TODO(hbagdi): re-render CRDs once controller-tools supports union tags: - https://github.com/kubernetes-sigs/controller-tools/pull/298 - https://github.com/kubernetes-sigs/controller-tools/issues/461
 *
 * @schema HttpRouteSpecHostsRulesForwardToFilters
 */
export interface HttpRouteSpecHostsRulesForwardToFilters {
  /**
   * ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  The resource may be "configmap" (use the empty string for the group) or an implementation-defined resource (for example, resource "myroutefilters" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "configmaps". ExtensionRef MUST NOT be used for core and extended filters.
   *
   * @schema HttpRouteSpecHostsRulesForwardToFilters#extensionRef
   */
  readonly extensionRef?: HttpRouteSpecHostsRulesForwardToFiltersExtensionRef;

  /**
   * HTTPRequestHeaderFilter defines configuration for the RequestHeader filter.
   *
   * @schema HttpRouteSpecHostsRulesForwardToFilters#requestHeader
   */
  readonly requestHeader: HttpRouteSpecHostsRulesForwardToFiltersRequestHeader;

  /**
   * HTTPRequestMirrorFilter defines configuration for the RequestMirror filter.
   *
   * @schema HttpRouteSpecHostsRulesForwardToFilters#requestMirror
   */
  readonly requestMirror: HttpRouteSpecHostsRulesForwardToFiltersRequestMirror;

  /**
   * Type identifies the filter to execute. Types are classified into three conformance-levels (similar to other locations in this API): - Core and extended: These filter types and their corresponding configuration   is defined in this package. All implementations must implement   the core filters. Implementers are encouraged to support extended filters.   Definitions for filter-specific configuration for these   filters is defined in this package. - Custom: These filters are defined and supported by specific vendors.   In the future, filters showing convergence in behavior across multiple   implementations will be considered for inclusion in extended or core   conformance rings. Filter-specific configuration for such filters   is specified using the ExtensionRef field. `Type` should be set to   "ImplementationSpecific" for custom filters. 
 Implementers are encouraged to define custom implementation types to extend the core API with implementation-specific behavior.
   *
   * @schema HttpRouteSpecHostsRulesForwardToFilters#type
   */
  readonly type: string;

}

/**
 * TargetRef is an object reference to forward matched requests to. The resource may be "services" (omit or use the empty string for the group), or an implementation may support other resources (for example, resource "myroutetargets" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "services".  If the referent cannot be found, the "InvalidRoutes" status condition on any Gateway that includes the HTTPRoute will be true. 
 Support: Core (Kubernetes Services) Support: Implementation-specific (Other resource types)
 *
 * @schema HttpRouteSpecHostsRulesForwardToTargetRef
 */
export interface HttpRouteSpecHostsRulesForwardToTargetRef {
  /**
   * Group is the group of the referent.  Omitting the value or specifying the empty string indicates the core API group.  For example, use the following to specify a service: 
 fooRef:   resource: services   name: myservice 
 Otherwise, if the core API group is not desired, specify the desired group: 
 fooRef:   group: acme.io   resource: foos   name: myfoo
   *
   * @schema HttpRouteSpecHostsRulesForwardToTargetRef#group
   */
  readonly group?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesForwardToTargetRef#name
   */
  readonly name: string;

  /**
   * Resource is the API resource name of the referent. Omitting the value or specifying the empty string indicates the services resource. For example, use the following to specify a services resource: 
 fooRef:   name: myservice 
 Otherwise, if the services resource is not desired, specify the desired group: 
 fooRef:   group: acme.io   resource: foos   name: myfoo
   *
   * @schema HttpRouteSpecHostsRulesForwardToTargetRef#resource
   */
  readonly resource?: string;

}

/**
 * HeaderMatchType specifies how to match a HTTP request header against the Values map. 
 Support: core (Exact) Support: custom (ImplementationSpecific) 
 Default: "Exact"
 *
 * @schema HttpRouteSpecHostsRulesMatchesHeadersType
 */
export enum HttpRouteSpecHostsRulesMatchesHeadersType {
  /** Exact */
  EXACT = "Exact",
  /** ImplementationSpecific */
  IMPLEMENTATION_SPECIFIC = "ImplementationSpecific",
}

/**
 * Type specifies how to match against the path Value. 
 Support: core (Exact, Prefix) Support: custom (RegularExpression, ImplementationSpecific) 
 Since RegularExpression PathType has custom conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect. 
 Default: "Prefix"
 *
 * @schema HttpRouteSpecHostsRulesMatchesPathType
 */
export enum HttpRouteSpecHostsRulesMatchesPathType {
  /** Exact */
  EXACT = "Exact",
  /** Prefix */
  PREFIX = "Prefix",
  /** RegularExpression */
  REGULAR_EXPRESSION = "RegularExpression",
  /** ImplementationSpecific */
  IMPLEMENTATION_SPECIFIC = "ImplementationSpecific",
}

/**
 * ExtensionRef is an optional, implementation-specific extension to the "filter" behavior.  The resource may be "configmap" (use the empty string for the group) or an implementation-defined resource (for example, resource "myroutefilters" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "configmaps". ExtensionRef MUST NOT be used for core and extended filters.
 *
 * @schema HttpRouteSpecHostsRulesForwardToFiltersExtensionRef
 */
export interface HttpRouteSpecHostsRulesForwardToFiltersExtensionRef {
  /**
   * Group is the API group name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesForwardToFiltersExtensionRef#group
   */
  readonly group: string;

  /**
   * Name is the name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesForwardToFiltersExtensionRef#name
   */
  readonly name: string;

  /**
   * Resource is the API resource name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesForwardToFiltersExtensionRef#resource
   */
  readonly resource: string;

}

/**
 * HTTPRequestHeaderFilter defines configuration for the RequestHeader filter.
 *
 * @schema HttpRouteSpecHostsRulesForwardToFiltersRequestHeader
 */
export interface HttpRouteSpecHostsRulesForwardToFiltersRequestHeader {
  /**
   * Add adds the given header (name, value) to the request before the action. 
 Input:   GET /foo HTTP/1.1 
 Config:   add: {"my-header": "foo"} 
 Output:   GET /foo HTTP/1.1   my-header: foo 
 Support: extended?
   *
   * @schema HttpRouteSpecHostsRulesForwardToFiltersRequestHeader#add
   */
  readonly add: { [key: string]: string };

  /**
   * Remove the given header(s) from the HTTP request before the action. The value of RemoveHeader is a list of HTTP header names. Note that the header names are case-insensitive [RFC-2616 4.2]. 
 Input:   GET /foo HTTP/1.1   My-Header1: ABC   My-Header2: DEF   My-Header2: GHI 
 Config:   remove: ["my-header1", "my-header3"] 
 Output:   GET /foo HTTP/1.1   My-Header2: DEF 
 Support: extended?
   *
   * @schema HttpRouteSpecHostsRulesForwardToFiltersRequestHeader#remove
   */
  readonly remove: string[];

}

/**
 * HTTPRequestMirrorFilter defines configuration for the RequestMirror filter.
 *
 * @schema HttpRouteSpecHostsRulesForwardToFiltersRequestMirror
 */
export interface HttpRouteSpecHostsRulesForwardToFiltersRequestMirror {
  /**
   * TargetPort specifies the destination port number to use for the TargetRef. If unspecified and TargetRef is a Service object consisting of a single port definition, that port will be used. If unspecified and TargetRef is a Service object consisting of multiple port definitions, an error is surfaced in status. 
 Support: Core
   *
   * @schema HttpRouteSpecHostsRulesForwardToFiltersRequestMirror#targetPort
   */
  readonly targetPort?: number;

  /**
   * TargetRef is an object reference to forward matched requests to. The resource may be "services" (omit or use the empty string for the group), or an implementation may support other resources (for example, resource "myroutetargets" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "services".  If the referent cannot be found, the "InvalidRoutes" status condition on any Gateway that includes the HTTPRoute will be true. 
 Support: Core (Kubernetes Services) Support: Implementation-specific (Other resource types)
   *
   * @schema HttpRouteSpecHostsRulesForwardToFiltersRequestMirror#targetRef
   */
  readonly targetRef: HttpRouteSpecHostsRulesForwardToFiltersRequestMirrorTargetRef;

}

/**
 * TargetRef is an object reference to forward matched requests to. The resource may be "services" (omit or use the empty string for the group), or an implementation may support other resources (for example, resource "myroutetargets" in group "networking.acme.io"). Omitting or specifying the empty string for both the resource and group indicates that the resource is "services".  If the referent cannot be found, the "InvalidRoutes" status condition on any Gateway that includes the HTTPRoute will be true. 
 Support: Core (Kubernetes Services) Support: Implementation-specific (Other resource types)
 *
 * @schema HttpRouteSpecHostsRulesForwardToFiltersRequestMirrorTargetRef
 */
export interface HttpRouteSpecHostsRulesForwardToFiltersRequestMirrorTargetRef {
  /**
   * Group is the group of the referent.  Omitting the value or specifying the empty string indicates the core API group.  For example, use the following to specify a service: 
 fooRef:   resource: services   name: myservice 
 Otherwise, if the core API group is not desired, specify the desired group: 
 fooRef:   group: acme.io   resource: foos   name: myfoo
   *
   * @schema HttpRouteSpecHostsRulesForwardToFiltersRequestMirrorTargetRef#group
   */
  readonly group?: string;

  /**
   * Name is the name of the referent.
   *
   * @schema HttpRouteSpecHostsRulesForwardToFiltersRequestMirrorTargetRef#name
   */
  readonly name: string;

  /**
   * Resource is the API resource name of the referent. Omitting the value or specifying the empty string indicates the services resource. For example, use the following to specify a services resource: 
 fooRef:   name: myservice 
 Otherwise, if the services resource is not desired, specify the desired group: 
 fooRef:   group: acme.io   resource: foos   name: myfoo
   *
   * @schema HttpRouteSpecHostsRulesForwardToFiltersRequestMirrorTargetRef#resource
   */
  readonly resource?: string;

}

