"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.App = void 0;
const constructs_1 = require("constructs");
const fs = require("fs");
const chart_1 = require("./chart");
const path = require("path");
const yaml_1 = require("./yaml");
const dependency_1 = require("./dependency");
const api_object_1 = require("./api-object");
/**
 * Represents a cdk8s application.
 */
class App extends constructs_1.Construct {
    /**
     * Defines an app
     * @param options configuration options
     */
    constructor(options = {}) {
        var _a, _b;
        super(undefined, '');
        this.outdir = (_b = (_a = options.outdir) !== null && _a !== void 0 ? _a : process.env.CDK8S_OUTDIR) !== null && _b !== void 0 ? _b : 'dist';
    }
    /**
     * Synthesizes all manifests to the output directory
     */
    synth() {
        fs.mkdirSync(this.outdir, { recursive: true });
        // this is kind of sucky, eventually I would like the DependencyGraph
        // to be able to answer this question.
        const hasDependantCharts = resolveDependencies(this);
        // Since we plan on removing the distributed synth mechanism, we no longer call `Node.synthesize`, but rather simply implement
        // the necessary operations. We do however want to preserve the distributed validation.
        validate(this);
        const simpleManifestNamer = (chart) => `${constructs_1.Node.of(chart).uniqueId}.k8s.yaml`;
        const manifestNamer = hasDependantCharts ? (chart) => `${index.toString().padStart(4, '0')}-${simpleManifestNamer(chart)}` : simpleManifestNamer;
        const charts = new dependency_1.DependencyGraph(constructs_1.Node.of(this)).topology().filter(x => x instanceof chart_1.Chart);
        let index = 0;
        for (const node of charts) {
            const chart = chart_1.Chart.of(node);
            yaml_1.Yaml.save(path.join(this.outdir, manifestNamer(chart)), chartToKube(chart));
            index++;
        }
    }
    /**
     * Synthesize a single chart.
     *
     * Each element returned in the resulting array represents a different ApiObject
     * in the scope of the chart.
     *
     * Note that the returned array order is important. It is determined by the various dependencies between
     * the constructs in the chart, where the first element is the one without dependencies, and so on...
     *
     * @returns An array of JSON objects.
     * @param chart the chart to synthesize.
     * @internal
     */
    static _synthChart(chart) {
        const app = App.of(chart);
        // we must prepare the entire app before synthesizing the chart
        // because the dependency inference happens on the app level.
        resolveDependencies(app);
        // validate the app since we want to call onValidate of the relevant constructs.
        // note this will also call onValidate on constructs from possibly different charts,
        // but thats ok too since we no longer treat constructs as a self-contained synthesis unit.
        validate(app);
        return chartToKube(chart);
    }
    static of(c) {
        const scope = constructs_1.Node.of(c).scope;
        if (!scope) {
            // the app is the only construct without a scope.
            return c;
        }
        return App.of(scope);
    }
}
exports.App = App;
function validate(app) {
    // Note this is a copy-paste of https://github.com/aws/constructs/blob/master/lib/construct.ts#L438.
    const errors = constructs_1.Node.of(app).validate();
    if (errors.length > 0) {
        const errorList = errors.map(e => `[${constructs_1.Node.of(e.source).path}] ${e.message}`).join('\n  ');
        throw new Error(`Validation failed with the following errors:\n  ${errorList}`);
    }
}
function resolveDependencies(app) {
    let hasDependantCharts = false;
    for (const dep of constructs_1.Node.of(app).dependencies) {
        // create explicit api object dependencies from implicit construct dependencies
        const targetApiObjects = constructs_1.Node.of(dep.target).findAll().filter(c => c instanceof api_object_1.ApiObject);
        const sourceApiObjects = constructs_1.Node.of(dep.source).findAll().filter(c => c instanceof api_object_1.ApiObject);
        for (const target of targetApiObjects) {
            for (const source of sourceApiObjects) {
                constructs_1.Node.of(source).addDependency(target);
            }
        }
        // create an explicit chart dependency from implicit construct dependencies
        const sourceChart = chart_1.Chart.of(dep.source);
        const targetChart = chart_1.Chart.of(dep.target);
        if (sourceChart !== targetChart) {
            constructs_1.Node.of(sourceChart).addDependency(targetChart);
            hasDependantCharts = true;
        }
    }
    return hasDependantCharts;
}
function chartToKube(chart) {
    return new dependency_1.DependencyGraph(constructs_1.Node.of(chart)).topology()
        .filter(x => x instanceof api_object_1.ApiObject)
        .map(x => x.toJson());
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2FwcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwyQ0FBeUQ7QUFDekQseUJBQXlCO0FBQ3pCLG1DQUFnQztBQUNoQyw2QkFBNkI7QUFDN0IsaUNBQThCO0FBQzlCLDZDQUErQztBQUMvQyw2Q0FBeUM7QUFXekM7O0dBRUc7QUFDSCxNQUFhLEdBQUksU0FBUSxzQkFBUztJQU1oQzs7O09BR0c7SUFDSCxZQUFZLFVBQXNCLEVBQUc7O1FBQ25DLEtBQUssQ0FBQyxTQUFnQixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxNQUFNLGVBQUcsT0FBTyxDQUFDLE1BQU0sbUNBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLG1DQUFJLE1BQU0sQ0FBQztJQUNyRSxDQUFDO0lBRUQ7O09BRUc7SUFDSSxLQUFLO1FBRVYsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFFL0MscUVBQXFFO1FBQ3JFLHNDQUFzQztRQUN0QyxNQUFNLGtCQUFrQixHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXJELDhIQUE4SDtRQUM5SCx1RkFBdUY7UUFDdkYsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWYsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLEtBQVksRUFBRSxFQUFFLENBQUMsR0FBRyxpQkFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLFdBQVcsQ0FBQztRQUNwRixNQUFNLGFBQWEsR0FBRyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFZLEVBQUUsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLElBQUksbUJBQW1CLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUM7UUFFeEosTUFBTSxNQUFNLEdBQWlCLElBQUksNEJBQWUsQ0FBQyxpQkFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxhQUFLLENBQUMsQ0FBQztRQUUzRyxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7UUFDZCxLQUFLLE1BQU0sSUFBSSxJQUFJLE1BQU0sRUFBRTtZQUN6QixNQUFNLEtBQUssR0FBVSxhQUFLLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3BDLFdBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzVFLEtBQUssRUFBRSxDQUFDO1NBQ1Q7SUFFSCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0ksTUFBTSxDQUFDLFdBQVcsQ0FBQyxLQUFZO1FBRXBDLE1BQU0sR0FBRyxHQUFRLEdBQUcsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFL0IsK0RBQStEO1FBQy9ELDZEQUE2RDtRQUM3RCxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUV6QixnRkFBZ0Y7UUFDaEYsb0ZBQW9GO1FBQ3BGLDJGQUEyRjtRQUMzRixRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFZCxPQUFPLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRU8sTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFhO1FBRTdCLE1BQU0sS0FBSyxHQUFHLGlCQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUUvQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1YsaURBQWlEO1lBQ2pELE9BQU8sQ0FBUSxDQUFDO1NBQ2pCO1FBRUQsT0FBTyxHQUFHLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7Q0FFRjtBQXJGRCxrQkFxRkM7QUFFRCxTQUFTLFFBQVEsQ0FBQyxHQUFRO0lBRXhCLG9HQUFvRztJQUNwRyxNQUFNLE1BQU0sR0FBRyxpQkFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUN2QyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3JCLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLGlCQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzNGLE1BQU0sSUFBSSxLQUFLLENBQUMsbURBQW1ELFNBQVMsRUFBRSxDQUFDLENBQUM7S0FDakY7QUFFSCxDQUFDO0FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxHQUFRO0lBRW5DLElBQUksa0JBQWtCLEdBQUcsS0FBSyxDQUFDO0lBRS9CLEtBQUssTUFBTSxHQUFHLElBQUksaUJBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsWUFBWSxFQUFFO1FBRTNDLCtFQUErRTtRQUMvRSxNQUFNLGdCQUFnQixHQUFHLGlCQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksc0JBQVMsQ0FBQyxDQUFDO1FBQzNGLE1BQU0sZ0JBQWdCLEdBQUcsaUJBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxzQkFBUyxDQUFDLENBQUM7UUFFM0YsS0FBSyxNQUFNLE1BQU0sSUFBSSxnQkFBZ0IsRUFBRTtZQUNyQyxLQUFLLE1BQU0sTUFBTSxJQUFJLGdCQUFnQixFQUFFO2dCQUNyQyxpQkFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDdkM7U0FDRjtRQUVELDJFQUEyRTtRQUMzRSxNQUFNLFdBQVcsR0FBRyxhQUFLLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6QyxNQUFNLFdBQVcsR0FBRyxhQUFLLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV6QyxJQUFJLFdBQVcsS0FBSyxXQUFXLEVBQUU7WUFDL0IsaUJBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ2hELGtCQUFrQixHQUFHLElBQUksQ0FBQztTQUMzQjtLQUVGO0lBRUQsT0FBTyxrQkFBa0IsQ0FBQztBQUU1QixDQUFDO0FBRUQsU0FBUyxXQUFXLENBQUMsS0FBWTtJQUMvQixPQUFPLElBQUksNEJBQWUsQ0FBQyxpQkFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRTtTQUNsRCxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksc0JBQVMsQ0FBQztTQUNuQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBRSxDQUFlLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztBQUN6QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29uc3RydWN0LCBOb2RlLCBJQ29uc3RydWN0IH0gZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBDaGFydCB9IGZyb20gJy4vY2hhcnQnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IFlhbWwgfSBmcm9tICcuL3lhbWwnO1xuaW1wb3J0IHsgRGVwZW5kZW5jeUdyYXBoIH0gZnJvbSAnLi9kZXBlbmRlbmN5JztcbmltcG9ydCB7IEFwaU9iamVjdCB9IGZyb20gJy4vYXBpLW9iamVjdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgZGlyZWN0b3J5IHRvIG91dHB1dCBLdWJlcm5ldGVzIG1hbmlmZXN0cy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBDREs4U19PVVRESVIgaWYgZGVmaW5lZCwgb3RoZXJ3aXNlIFwiZGlzdFwiXG4gICAqL1xuICByZWFkb25seSBvdXRkaXI/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNkazhzIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQXBwIGV4dGVuZHMgQ29uc3RydWN0IHtcbiAgLyoqXG4gICAqIFRoZSBvdXRwdXQgZGlyZWN0b3J5IGludG8gd2hpY2ggbWFuaWZlc3RzIHdpbGwgYmUgc3ludGhlc2l6ZWQuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgb3V0ZGlyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYW4gYXBwXG4gICAqIEBwYXJhbSBvcHRpb25zIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9uczogQXBwT3B0aW9ucyA9IHsgfSkge1xuICAgIHN1cGVyKHVuZGVmaW5lZCBhcyBhbnksICcnKTtcbiAgICB0aGlzLm91dGRpciA9IG9wdGlvbnMub3V0ZGlyID8/IHByb2Nlc3MuZW52LkNESzhTX09VVERJUiA/PyAnZGlzdCc7XG4gIH1cblxuICAvKipcbiAgICogU3ludGhlc2l6ZXMgYWxsIG1hbmlmZXN0cyB0byB0aGUgb3V0cHV0IGRpcmVjdG9yeVxuICAgKi9cbiAgcHVibGljIHN5bnRoKCk6IHZvaWQge1xuXG4gICAgZnMubWtkaXJTeW5jKHRoaXMub3V0ZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcblxuICAgIC8vIHRoaXMgaXMga2luZCBvZiBzdWNreSwgZXZlbnR1YWxseSBJIHdvdWxkIGxpa2UgdGhlIERlcGVuZGVuY3lHcmFwaFxuICAgIC8vIHRvIGJlIGFibGUgdG8gYW5zd2VyIHRoaXMgcXVlc3Rpb24uXG4gICAgY29uc3QgaGFzRGVwZW5kYW50Q2hhcnRzID0gcmVzb2x2ZURlcGVuZGVuY2llcyh0aGlzKTtcblxuICAgIC8vIFNpbmNlIHdlIHBsYW4gb24gcmVtb3ZpbmcgdGhlIGRpc3RyaWJ1dGVkIHN5bnRoIG1lY2hhbmlzbSwgd2Ugbm8gbG9uZ2VyIGNhbGwgYE5vZGUuc3ludGhlc2l6ZWAsIGJ1dCByYXRoZXIgc2ltcGx5IGltcGxlbWVudFxuICAgIC8vIHRoZSBuZWNlc3Nhcnkgb3BlcmF0aW9ucy4gV2UgZG8gaG93ZXZlciB3YW50IHRvIHByZXNlcnZlIHRoZSBkaXN0cmlidXRlZCB2YWxpZGF0aW9uLlxuICAgIHZhbGlkYXRlKHRoaXMpO1xuXG4gICAgY29uc3Qgc2ltcGxlTWFuaWZlc3ROYW1lciA9IChjaGFydDogQ2hhcnQpID0+IGAke05vZGUub2YoY2hhcnQpLnVuaXF1ZUlkfS5rOHMueWFtbGA7XG4gICAgY29uc3QgbWFuaWZlc3ROYW1lciA9IGhhc0RlcGVuZGFudENoYXJ0cyA/IChjaGFydDogQ2hhcnQpID0+IGAke2luZGV4LnRvU3RyaW5nKCkucGFkU3RhcnQoNCwgJzAnKX0tJHtzaW1wbGVNYW5pZmVzdE5hbWVyKGNoYXJ0KX1gIDogc2ltcGxlTWFuaWZlc3ROYW1lcjtcblxuICAgIGNvbnN0IGNoYXJ0czogSUNvbnN0cnVjdFtdID0gbmV3IERlcGVuZGVuY3lHcmFwaChOb2RlLm9mKHRoaXMpKS50b3BvbG9neSgpLmZpbHRlcih4ID0+IHggaW5zdGFuY2VvZiBDaGFydCk7XG5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjaGFydHMpIHtcbiAgICAgIGNvbnN0IGNoYXJ0OiBDaGFydCA9IENoYXJ0Lm9mKG5vZGUpO1xuICAgICAgWWFtbC5zYXZlKHBhdGguam9pbih0aGlzLm91dGRpciwgbWFuaWZlc3ROYW1lcihjaGFydCkpLCBjaGFydFRvS3ViZShjaGFydCkpO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBTeW50aGVzaXplIGEgc2luZ2xlIGNoYXJ0LlxuICAgKlxuICAgKiBFYWNoIGVsZW1lbnQgcmV0dXJuZWQgaW4gdGhlIHJlc3VsdGluZyBhcnJheSByZXByZXNlbnRzIGEgZGlmZmVyZW50IEFwaU9iamVjdFxuICAgKiBpbiB0aGUgc2NvcGUgb2YgdGhlIGNoYXJ0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIHJldHVybmVkIGFycmF5IG9yZGVyIGlzIGltcG9ydGFudC4gSXQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdmFyaW91cyBkZXBlbmRlbmNpZXMgYmV0d2VlblxuICAgKiB0aGUgY29uc3RydWN0cyBpbiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZSBvbmUgd2l0aG91dCBkZXBlbmRlbmNpZXMsIGFuZCBzbyBvbi4uLlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBKU09OIG9iamVjdHMuXG4gICAqIEBwYXJhbSBjaGFydCB0aGUgY2hhcnQgdG8gc3ludGhlc2l6ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIF9zeW50aENoYXJ0KGNoYXJ0OiBDaGFydCk6IGFueVtdIHtcblxuICAgIGNvbnN0IGFwcDogQXBwID0gQXBwLm9mKGNoYXJ0KTtcblxuICAgIC8vIHdlIG11c3QgcHJlcGFyZSB0aGUgZW50aXJlIGFwcCBiZWZvcmUgc3ludGhlc2l6aW5nIHRoZSBjaGFydFxuICAgIC8vIGJlY2F1c2UgdGhlIGRlcGVuZGVuY3kgaW5mZXJlbmNlIGhhcHBlbnMgb24gdGhlIGFwcCBsZXZlbC5cbiAgICByZXNvbHZlRGVwZW5kZW5jaWVzKGFwcCk7XG5cbiAgICAvLyB2YWxpZGF0ZSB0aGUgYXBwIHNpbmNlIHdlIHdhbnQgdG8gY2FsbCBvblZhbGlkYXRlIG9mIHRoZSByZWxldmFudCBjb25zdHJ1Y3RzLlxuICAgIC8vIG5vdGUgdGhpcyB3aWxsIGFsc28gY2FsbCBvblZhbGlkYXRlIG9uIGNvbnN0cnVjdHMgZnJvbSBwb3NzaWJseSBkaWZmZXJlbnQgY2hhcnRzLFxuICAgIC8vIGJ1dCB0aGF0cyBvayB0b28gc2luY2Ugd2Ugbm8gbG9uZ2VyIHRyZWF0IGNvbnN0cnVjdHMgYXMgYSBzZWxmLWNvbnRhaW5lZCBzeW50aGVzaXMgdW5pdC5cbiAgICB2YWxpZGF0ZShhcHApO1xuXG4gICAgcmV0dXJuIGNoYXJ0VG9LdWJlKGNoYXJ0KTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIG9mKGM6IElDb25zdHJ1Y3QpOiBBcHAge1xuXG4gICAgY29uc3Qgc2NvcGUgPSBOb2RlLm9mKGMpLnNjb3BlO1xuXG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgLy8gdGhlIGFwcCBpcyB0aGUgb25seSBjb25zdHJ1Y3Qgd2l0aG91dCBhIHNjb3BlLlxuICAgICAgcmV0dXJuIGMgYXMgQXBwO1xuICAgIH1cblxuICAgIHJldHVybiBBcHAub2Yoc2NvcGUpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGUoYXBwOiBBcHApIHtcblxuICAvLyBOb3RlIHRoaXMgaXMgYSBjb3B5LXBhc3RlIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvY29uc3RydWN0cy9ibG9iL21hc3Rlci9saWIvY29uc3RydWN0LnRzI0w0MzguXG4gIGNvbnN0IGVycm9ycyA9IE5vZGUub2YoYXBwKS52YWxpZGF0ZSgpO1xuICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBlcnJvckxpc3QgPSBlcnJvcnMubWFwKGUgPT4gYFske05vZGUub2YoZS5zb3VyY2UpLnBhdGh9XSAke2UubWVzc2FnZX1gKS5qb2luKCdcXG4gICcpO1xuICAgIHRocm93IG5ldyBFcnJvcihgVmFsaWRhdGlvbiBmYWlsZWQgd2l0aCB0aGUgZm9sbG93aW5nIGVycm9yczpcXG4gICR7ZXJyb3JMaXN0fWApO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURlcGVuZGVuY2llcyhhcHA6IEFwcCkge1xuXG4gIGxldCBoYXNEZXBlbmRhbnRDaGFydHMgPSBmYWxzZTtcblxuICBmb3IgKGNvbnN0IGRlcCBvZiBOb2RlLm9mKGFwcCkuZGVwZW5kZW5jaWVzKSB7XG5cbiAgICAvLyBjcmVhdGUgZXhwbGljaXQgYXBpIG9iamVjdCBkZXBlbmRlbmNpZXMgZnJvbSBpbXBsaWNpdCBjb25zdHJ1Y3QgZGVwZW5kZW5jaWVzXG4gICAgY29uc3QgdGFyZ2V0QXBpT2JqZWN0cyA9IE5vZGUub2YoZGVwLnRhcmdldCkuZmluZEFsbCgpLmZpbHRlcihjID0+IGMgaW5zdGFuY2VvZiBBcGlPYmplY3QpO1xuICAgIGNvbnN0IHNvdXJjZUFwaU9iamVjdHMgPSBOb2RlLm9mKGRlcC5zb3VyY2UpLmZpbmRBbGwoKS5maWx0ZXIoYyA9PiBjIGluc3RhbmNlb2YgQXBpT2JqZWN0KTtcblxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldEFwaU9iamVjdHMpIHtcbiAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZUFwaU9iamVjdHMpIHtcbiAgICAgICAgTm9kZS5vZihzb3VyY2UpLmFkZERlcGVuZGVuY3kodGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYW4gZXhwbGljaXQgY2hhcnQgZGVwZW5kZW5jeSBmcm9tIGltcGxpY2l0IGNvbnN0cnVjdCBkZXBlbmRlbmNpZXNcbiAgICBjb25zdCBzb3VyY2VDaGFydCA9IENoYXJ0Lm9mKGRlcC5zb3VyY2UpO1xuICAgIGNvbnN0IHRhcmdldENoYXJ0ID0gQ2hhcnQub2YoZGVwLnRhcmdldCk7XG5cbiAgICBpZiAoc291cmNlQ2hhcnQgIT09IHRhcmdldENoYXJ0KSB7XG4gICAgICBOb2RlLm9mKHNvdXJjZUNoYXJ0KS5hZGREZXBlbmRlbmN5KHRhcmdldENoYXJ0KTtcbiAgICAgIGhhc0RlcGVuZGFudENoYXJ0cyA9IHRydWU7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gaGFzRGVwZW5kYW50Q2hhcnRzO1xuXG59XG5cbmZ1bmN0aW9uIGNoYXJ0VG9LdWJlKGNoYXJ0OiBDaGFydCkge1xuICByZXR1cm4gbmV3IERlcGVuZGVuY3lHcmFwaChOb2RlLm9mKGNoYXJ0KSkudG9wb2xvZ3koKVxuICAgIC5maWx0ZXIoeCA9PiB4IGluc3RhbmNlb2YgQXBpT2JqZWN0KVxuICAgIC5tYXAoeCA9PiAoeCBhcyBBcGlPYmplY3QpLnRvSnNvbigpKTtcbn0iXX0=