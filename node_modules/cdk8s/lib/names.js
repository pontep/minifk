"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Names = void 0;
const crypto = require("crypto");
const MAX_DNS_NAME_LEN = 63;
const VALIDATE = /^[0-9a-z-]+$/;
const HASH_LEN = 8;
/**
 * Utilities for generating unique and stable names.
 */
class Names {
    /**
     * Generates a unique and stable name compatible DNS_LABEL from RFC-1123 from
     * a path.
     *
     * The generated name will:
     *  - contain at most 63 characters
     *  - contain only lowercase alphanumeric characters or ‘-’
     *  - start with an alphanumeric character
     *  - end with an alphanumeric character
     *
     * The generated name will have the form:
     *  <comp0>-<comp1>-..-<compN>-<short-hash>
     *
     * Where <comp> are the path components (assuming they are is separated by
     * "/").
     *
     * Note that if the total length is longer than 63 characters, we will trim
     * the first components since the last components usually encode more meaning.
     *
     * @link https://tools.ietf.org/html/rfc1123
     *
     * @param path a path to a node (components separated by "/")
     * @param maxLen maximum allowed length for name
     * @throws if any of the components do not adhere to naming constraints or
     * length.
     */
    static toDnsLabel(path, maxLen = MAX_DNS_NAME_LEN) {
        if (maxLen < HASH_LEN) {
            throw new Error(`minimum max length for object names is ${HASH_LEN} (required for hash)`);
        }
        let components = path.split('/');
        // special case: if we only have one component in our path and it adheres to DNS_NAME, we don't decorate it
        if (components.length === 1 && VALIDATE.test(components[0]) && components[0].length <= maxLen) {
            return components[0];
        }
        // okay, now we need to normalize all components to adhere to DNS_NAME and append the hash of the full path.
        components = components.map(c => normalizeToDnsName(c, maxLen));
        components.push(calcHash(path, HASH_LEN));
        return components
            .reverse()
            .filter(omitDuplicates)
            .join('/')
            .slice(0, maxLen)
            .split('/')
            .reverse()
            .filter(x => x)
            .join('-');
    }
    /* istanbul ignore next */
    constructor() {
        return;
    }
}
exports.Names = Names;
function omitDuplicates(value, index, components) {
    return value !== components[index - 1];
}
function normalizeToDnsName(c, maxLen) {
    return c
        .toLocaleLowerCase() // lower case
        .replace(/[^0-9a-z-]/g, '') // remove non-allowed characters
        .substr(0, maxLen); // trim to maxLength
}
function calcHash(path, maxLen) {
    const hash = crypto.createHash('sha256');
    hash.update(path);
    return hash.digest('hex').slice(0, maxLen);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmFtZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbmFtZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaUNBQWlDO0FBRWpDLE1BQU0sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDO0FBQzVCLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQztBQUNoQyxNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFFbkI7O0dBRUc7QUFDSCxNQUFhLEtBQUs7SUFDaEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F5Qkc7SUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDLElBQVksRUFBRSxNQUFNLEdBQUcsZ0JBQWdCO1FBQzlELElBQUksTUFBTSxHQUFHLFFBQVEsRUFBRTtZQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLDBDQUEwQyxRQUFRLHNCQUFzQixDQUFDLENBQUM7U0FDM0Y7UUFFRCxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWpDLDJHQUEyRztRQUMzRyxJQUFJLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxNQUFNLEVBQUU7WUFDN0YsT0FBTyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEI7UUFFRCw0R0FBNEc7UUFDNUcsVUFBVSxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUVoRSxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUUxQyxPQUFPLFVBQVU7YUFDZCxPQUFPLEVBQUU7YUFDVCxNQUFNLENBQUMsY0FBYyxDQUFDO2FBQ3RCLElBQUksQ0FBQyxHQUFHLENBQUM7YUFDVCxLQUFLLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQzthQUNoQixLQUFLLENBQUMsR0FBRyxDQUFDO2FBQ1YsT0FBTyxFQUFFO2FBQ1QsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ2QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2YsQ0FBQztJQUVELDBCQUEwQjtJQUMxQjtRQUNFLE9BQU87SUFDVCxDQUFDO0NBQ0Y7QUEzREQsc0JBMkRDO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBYSxFQUFFLEtBQWEsRUFBRSxVQUFvQjtJQUN4RSxPQUFPLEtBQUssS0FBSyxVQUFVLENBQUMsS0FBSyxHQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZDLENBQUM7QUFFRCxTQUFTLGtCQUFrQixDQUFDLENBQVMsRUFBRSxNQUFjO0lBQ25ELE9BQU8sQ0FBQztTQUNMLGlCQUFpQixFQUFFLENBQVEsYUFBYTtTQUN4QyxPQUFPLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxDQUFDLGdDQUFnQztTQUMzRCxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFBLENBQVUsb0JBQW9CO0FBQ3BELENBQUM7QUFFRCxTQUFTLFFBQVEsQ0FBQyxJQUFZLEVBQUUsTUFBYztJQUM1QyxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDbEIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDN0MsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5jb25zdCBNQVhfRE5TX05BTUVfTEVOID0gNjM7XG5jb25zdCBWQUxJREFURSA9IC9eWzAtOWEtei1dKyQvO1xuY29uc3QgSEFTSF9MRU4gPSA4O1xuXG4vKipcbiAqIFV0aWxpdGllcyBmb3IgZ2VuZXJhdGluZyB1bmlxdWUgYW5kIHN0YWJsZSBuYW1lcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE5hbWVzIHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBhbmQgc3RhYmxlIG5hbWUgY29tcGF0aWJsZSBETlNfTEFCRUwgZnJvbSBSRkMtMTEyMyBmcm9tXG4gICAqIGEgcGF0aC5cbiAgICpcbiAgICogVGhlIGdlbmVyYXRlZCBuYW1lIHdpbGw6XG4gICAqICAtIGNvbnRhaW4gYXQgbW9zdCA2MyBjaGFyYWN0ZXJzXG4gICAqICAtIGNvbnRhaW4gb25seSBsb3dlcmNhc2UgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgb3Ig4oCYLeKAmVxuICAgKiAgLSBzdGFydCB3aXRoIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJcbiAgICogIC0gZW5kIHdpdGggYW4gYWxwaGFudW1lcmljIGNoYXJhY3RlclxuICAgKlxuICAgKiBUaGUgZ2VuZXJhdGVkIG5hbWUgd2lsbCBoYXZlIHRoZSBmb3JtOlxuICAgKiAgPGNvbXAwPi08Y29tcDE+LS4uLTxjb21wTj4tPHNob3J0LWhhc2g+XG4gICAqXG4gICAqIFdoZXJlIDxjb21wPiBhcmUgdGhlIHBhdGggY29tcG9uZW50cyAoYXNzdW1pbmcgdGhleSBhcmUgaXMgc2VwYXJhdGVkIGJ5XG4gICAqIFwiL1wiKS5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHRoZSB0b3RhbCBsZW5ndGggaXMgbG9uZ2VyIHRoYW4gNjMgY2hhcmFjdGVycywgd2Ugd2lsbCB0cmltXG4gICAqIHRoZSBmaXJzdCBjb21wb25lbnRzIHNpbmNlIHRoZSBsYXN0IGNvbXBvbmVudHMgdXN1YWxseSBlbmNvZGUgbW9yZSBtZWFuaW5nLlxuICAgKlxuICAgKiBAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTEyM1xuICAgKlxuICAgKiBAcGFyYW0gcGF0aCBhIHBhdGggdG8gYSBub2RlIChjb21wb25lbnRzIHNlcGFyYXRlZCBieSBcIi9cIilcbiAgICogQHBhcmFtIG1heExlbiBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoIGZvciBuYW1lXG4gICAqIEB0aHJvd3MgaWYgYW55IG9mIHRoZSBjb21wb25lbnRzIGRvIG5vdCBhZGhlcmUgdG8gbmFtaW5nIGNvbnN0cmFpbnRzIG9yXG4gICAqIGxlbmd0aC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgdG9EbnNMYWJlbChwYXRoOiBzdHJpbmcsIG1heExlbiA9IE1BWF9ETlNfTkFNRV9MRU4pIHtcbiAgICBpZiAobWF4TGVuIDwgSEFTSF9MRU4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbWluaW11bSBtYXggbGVuZ3RoIGZvciBvYmplY3QgbmFtZXMgaXMgJHtIQVNIX0xFTn0gKHJlcXVpcmVkIGZvciBoYXNoKWApO1xuICAgIH1cblxuICAgIGxldCBjb21wb25lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuXG4gICAgLy8gc3BlY2lhbCBjYXNlOiBpZiB3ZSBvbmx5IGhhdmUgb25lIGNvbXBvbmVudCBpbiBvdXIgcGF0aCBhbmQgaXQgYWRoZXJlcyB0byBETlNfTkFNRSwgd2UgZG9uJ3QgZGVjb3JhdGUgaXRcbiAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDEgJiYgVkFMSURBVEUudGVzdChjb21wb25lbnRzWzBdKSAmJiBjb21wb25lbnRzWzBdLmxlbmd0aCA8PSBtYXhMZW4pIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRzWzBdO1xuICAgIH1cblxuICAgIC8vIG9rYXksIG5vdyB3ZSBuZWVkIHRvIG5vcm1hbGl6ZSBhbGwgY29tcG9uZW50cyB0byBhZGhlcmUgdG8gRE5TX05BTUUgYW5kIGFwcGVuZCB0aGUgaGFzaCBvZiB0aGUgZnVsbCBwYXRoLlxuICAgIGNvbXBvbmVudHMgPSBjb21wb25lbnRzLm1hcChjID0+IG5vcm1hbGl6ZVRvRG5zTmFtZShjLCBtYXhMZW4pKTtcblxuICAgIGNvbXBvbmVudHMucHVzaChjYWxjSGFzaChwYXRoLCBIQVNIX0xFTikpO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudHNcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maWx0ZXIob21pdER1cGxpY2F0ZXMpXG4gICAgICAuam9pbignLycpXG4gICAgICAuc2xpY2UoMCwgbWF4TGVuKVxuICAgICAgLnNwbGl0KCcvJylcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maWx0ZXIoeCA9PiB4KVxuICAgICAgLmpvaW4oJy0nKTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9taXREdXBsaWNhdGVzKHZhbHVlOiBzdHJpbmcsIGluZGV4OiBudW1iZXIsIGNvbXBvbmVudHM6IHN0cmluZ1tdKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gY29tcG9uZW50c1tpbmRleC0xXTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9EbnNOYW1lKGM6IHN0cmluZywgbWF4TGVuOiBudW1iZXIpIHtcbiAgcmV0dXJuIGNcbiAgICAudG9Mb2NhbGVMb3dlckNhc2UoKSAgICAgICAgLy8gbG93ZXIgY2FzZVxuICAgIC5yZXBsYWNlKC9bXjAtOWEtei1dL2csICcnKSAvLyByZW1vdmUgbm9uLWFsbG93ZWQgY2hhcmFjdGVyc1xuICAgIC5zdWJzdHIoMCwgbWF4TGVuKSAgICAgICAgICAvLyB0cmltIHRvIG1heExlbmd0aFxufVxuXG5mdW5jdGlvbiBjYWxjSGFzaChwYXRoOiBzdHJpbmcsIG1heExlbjogbnVtYmVyKSB7XG4gIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG4gIGhhc2gudXBkYXRlKHBhdGgpO1xuICByZXR1cm4gaGFzaC5kaWdlc3QoJ2hleCcpLnNsaWNlKDAsIG1heExlbik7XG59Il19